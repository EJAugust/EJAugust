<p>I find metaphors to be a useful way to develop and present new data structures. The <a href="https://en.wikipedia.org/wiki/Directory_(computing)#Folder_metaphor" target="_blank">file folder metaphor</a> is perhaps one of the most obvious examples of this utility. There are, of course, no <em>physical</em> folders inside the computer.</p>
<p>In this note, I explore the <a href="https://en.wikipedia.org/wiki/Multiverse" target="_blank">multiverse</a> as a key metaphor in a highly dynamic technology I'm designing called a Universal IDE (UIDE). It differentiates between two kinds of information.</p>
<h2>Two Kinds of Information</h2>
<p>Users typically interact with an application <em>without</em> those interactions changing the whole experience in fundamental ways. Nobody wants to <em>accidentally</em> change the laws of physics that make the application functional.</p>
<p>They're familiar with actions like browsing pages, creating and editing files, and perhaps adjusting its settings and layout.</p>
<p>What sets our hypothetical project apart, however, is that the user can also modify the source code of the application itself, from within the application. It unites <i>all</i> information into a single kind: precisely that which disambiguates one UIDE from all others. The UIDE is then used to edit this information - thus becoming a <em>different</em> UIDE. This can get a bit hairy, and the multiverse metaphor is an abstraction that restores some sanity.</p>
<p>To get an idea of this, think about web pages. Users are used to seeing the current page location reflected in their address bar, thanks to a routing system. Now imagine if the web application stored its <em>source code</em> in the address bar. The location of the page would define its behavior. We would lose the separation between <em>browsing</em> and <em>software engineering</em>.</p>
<p>If you're curious about this idea, check out my other notes, like <a href="#" onclick="_.com.ejaugust.www.notes.go(event, '1749276077')">this one from last week</a> which estimates how much storage space is available in a URL and hints at how the right design might make this achievable.</p>
<h2>In-Universe Information</h2>
<p>The empty document is static with no entropy. It can never change, because it offers no tools for changing its state. Picture it as an empty universe. This is the foundation of the multiverse.</p>
<p>Now, let's say we populate the empty document with a few images. We make it look pretty cool, but there's no navigation. Although images require information to exist - they still impart no entropy into the universe because the universe still offers no tools which can change its state. Sure, you can edit the URL, but there is no in-universe way to browse.</p>
<p>Now let's say we add a few settings like color mode and theme. These tools are now available to do <em>work</em> in our universe. They need to be mutable - they need to be able to take on different states (like having the drop-down menu opened or closed, adjusting panel widths, selecting a specific color, etc.). We finally have a universe with entropy, thanks to a mutable state space.</p>
<p>These simple tools don't edit their own behavior, just the look and feel of the page. There's no way to fundamentally transform the application using these tools. While the user is exploring this mutable state space, even if the source code/address of the page is changing a bit, we can still consider it as traveling around in <em>a single universe</em>.</p>
<p>If this is all the mutability we want our universe to have, and we don't care about the multiverse, we don't need to put the <em>entire</em> source code into the address bar. Instead, we can use something like a minimal perfect hash function to assign a URL to every in-universe state. This would keep the user locked-in to the current universe.</p>
<p>That is how <em>this website and surrounding platform</em> work. A space is made available for you to travel. That space doesn't include modifications to the source code. This makes it safe from XSS attacks and from crashes caused by user error.</p>
<h2>The Universal IDE</h2>
<p>Now, imagine that we added a few, shall we say, <em>enhanced</em> tools. These ones actually allow modification of the source code that allow all of the tools–including themselves–to operate. Now, the source code of the universe contributes entropy to the universe. When we start changing these tools, we can find ourselves in completely new universes. What is in-universe and out-of-universe is completely defined by the universe we're in. Such a space can be thought of as being occupied by universes that have varying degrees of "rift", a measure of how easily that universe allows users to access the multiverse.</p>
<p>If such an app were to be an integrated development environment (IDE), then it would require a usability design that provides a high degree of rift while still protecting its usability. I have taken to calling this kind of IDE a <em>universal</em> IDE (UIDE). A fully-featured UIDE is a program that can become any other UIDE by using its tools to modifying itself. By this definition, a UIDE can limit its state space to all those universes that meet our minimum rift and usability constraints without needing to access the rest. It can then offer a perfect hash function over that state space.</p>
<p>Such a multiverse is not a free and unrestricted multiverse but rather a very expansive but still singular universe that just happens to have <em>a model of the multiverse</em> within it.</p>
<p>The multiverse is a much more <em>interesting</em> and <em>dangerous</em> place. The user becomes responsible for defining and maintaining the "laws of physics" for their universe. This opens up some challenges from the perspective of cognitive ergonomics and that's where the multiverse metaphor as a usability abstraction comes in…</p>
<p>We can divide the UIDE's massive state space into two kinds of entropy: that which relates to <b>which</b> universe the user is in, and that which relates to <b>where</b> the user is within that universe.</p>
<h2>How Limited Should the Space Be?</h2>
<p>If <em>all</em> of a web app's source code can be modified by the user, then they can easily <em>destroy the universe.</em> They could even <em>erase the universe</em>, back to the blank document. Luckily, we're only talking about an application — not the actual universe. But still… that would mean being able to erase the tools themselves, which would leave the user stranded in that empty place.</p>
<p>This is where a well-defined Universal IDE comes into play. It provides tiered access to certain modifications, similar to how an operating system requires users to have certain privileges to make changes, while still allowing a high degree of modification. It does this by thoughtfully enforcing a separation between the universe and the multiverse.</p>
<p>If the user strips down the entire world using the in-universe tools, they will end up with a blank document. Only, that blank document will still have the necessary bootstrap with some immutable root-level fallbacks that allow them to start building new tools again from scratch.</p>
<p>The presented space should be expansive enough to include a well-spring of useful and creative applications. For example, it should be possible to find sophisticated and precise mathematical and engineering applications while also including a rich world of <em>games</em>, all without redefining that root behavior.</p>
<p>I expand further on this <em>Gamified</em> Universal IDE (GUIDE) concept <a href="#" onclick="_.com.ejaugust.www.notes.go(event, '1750075200')">in a later note</a>. There, I describe a fictional universe - one that should exist inside of our final UIDE state space.</p>
<h2>Quick Save to the Rescue</h2>
<p>In a <em>safe, reliable</em> universe, you should be able to move anywhere you want without destroying that universe (I think that's reasonable). Because each UIDE universe has a URL, that URL can be bookmarked - just in case the worst happens.</p>
<p>Think of it like a game whose save state uses entropy-perfect encoding to describe a significant amount of the game's behavior while maintaining certain read-only behavior that ensures that this entire state space is reachable–every possible save game file is eventually reachable from every other. This makes a UIDE a powerful tool from a development perspective. It would be impossible for someone to explore these spaces in one lifetime. Yet, it becomes easy and fun to save your place and get back to it later.</p>
<p>This is also a boon for debugging: being able to deep link directly to various edge cases greatly enhances the QA process.</p>
<h2>Conclusion</h2>
<p>The Universal IDE is a powerful concept that bridges science fiction with real life engineering. The multiverse may be able to serve as a useful metaphor in the context of this new technology.</p>
<p>The multiverse as an operating system abstraction is one of many ongoing threads that I'm exploring in pursuit of creating a real Universal IDE. Time will tell which of these threads pans out.</p>
<p>Thanks for reading!</p>